# Storage-Class Specifiers for External-Level Declarations
外部レベル宣言のストレージクラス指定子


外部変数:
ファイルスコープの変数。
関数の外部で定義され、多くの関数に使用できる可能性がある。
関数は外部レベルでのみ定義できるため、入れ子にできない。
※同じ名前の外部変数と関数へのすべての参照は同じオブジェクトへの参照であり、外部リンケージが含まれていることを意味する。(staticキーワードを使用して、この動作をオーバーライドできる。)

外部レベルの変数宣言:
変数の定義(宣言の定義)、または別の場所で定義された変数の参照(宣言の参照)

変数の初期化する(暗黙的または明示的に)外部変数宣言:
変数の定義宣言。外部レベルの定義は複数の形式にすることができる。
- staticストレージクラスで宣言する変数
定数式を使ってstatic変数を明示的に初期化できる。
初期化子を省略すると、変数は規定で0に初期化される。
例:下記の2つのステートメントはどちらも変数kの定義と見なされる。
```lang:C
static int k = 16;
static int k;
```
- 外部レベルで明示的に初期化する変数。
例:int j = 3;は変数jの定義。

外部レベルの変数宣言:
static,externストレージクラス指定子を使用するか、ストレージクラス指定子を完全に省略できる。
auto,register storage-class-specifierターミナルを外部レベルで使用することはできない。

外部レベルで変数を定義すると、変数は翻訳単位の残りの部分全体にわたって参照できる。
変数は、同じソースファイルでの宣言に先立って表示されない。
※参照宣言が表示されるようにしない限り、プログラムの他のソースファイルに表示されない。


staticに関する規則には以下が含まれる。
- staticキーワードなしですべてのブロック外部で宣言された変数:
プログラム全体を通して常に値を保持する。
特定の翻訳単位へのアクセスを制限するには、staticキーワードを使用する必要がある。
→内部リンケージが設定される。プログラム全体でグローバルにするには、明示的なストレージクラスを省略するか、キーワードexternを使用する。
- プログラム内で1回だけ、外部レベルで変数を定義できる。
同じ名前と別の翻訳単位のstaticストレージクラスの指定子を持つ別の変数を定義できる。
各static定義はその独自の翻訳単位内でのみ参照できるため、競合は発生しない。
1つの翻訳単位内の変数間で共有され、他の翻訳単位からは参照されない識別子名を簡単に隠すことができる。
- プログラム内で1回だけ、外部レベルで変数を定義できる。
同じ名前と別の翻訳単位のstaticストレージクラスの指定子を持つ別の変数を定義できる。
各static定義は、その独自の翻訳単位内でのみ参照できるため、競合は発生しない。
1つの翻訳単位内の関数間で共有され、他の翻訳単位からは参照されない識別子を簡単に隠すことができる。
- staticストレージクラス識別子は、関数にも適用できる。
関数staticを宣言する場合、その名前は宣言されているファイルの外部からは参照できない。

externを使用するための規則は以下のとおり。
- externストレージクラス指定子は、他の場所で定義された変数への参照を宣言する。
extern宣言を使用して、別のソースファイル内の定義を参照できるようにするか、同じソースファイルで変数の定義前にその変数を参照することが可能。
外部レベルで変数への参照を宣言すると、その変数は宣言した参照が発生する翻訳単位の残りの部分全体で参照できる。
- extern参照を有効にするには、参照する変数は1回だけ外部レベル定義する必要がある。
この定義(externストレージクラスを含まない)は、プログラムを構成する任意の翻訳単位内で行うことができる。

例
外部宣言を示す
```lang:C
/******************************************************************
                      SOURCE FILE ONE
*******************************************************************/
#include <stdio.h>

extern int i;                // Reference to i, defined below
extern void other ( void );  // Reference to other(), defined in second source file
void next( void );           // Function prototype

int main()
{
    i++;
    printf_s( "%d\n", i );   // i equals 4
    next();
}

int i = 3;                  // Definition of i

void next( void )
{
    i++;
    printf_s( "%d\n", i );  // i equals 5
    other();
}

/******************************************************************
                      SOURCE FILE TWO
*******************************************************************/
#include <stdio.h>

extern int i;              // Reference to i in
                           // first source file
void other( void )
{
    i++;
    printf_s( "%d\n", i ); // i equals 6
}
```
2つのソースファイルにはiの3つの外部宣言の合計が含まれる。
1つの宣言のみが定義宣言。

定義宣言
```lang:C
int i = 3;
```
定義宣言によって、グローバル変数iが定義され、初期値3で初期化される。
externを使用している最初のソースファイルの最上部にあるiの参照宣言により、ファイルの定義宣言の前にグローバル変数を参照できるようになる。

2番目のソースファイルのiの参照宣言:
ソースファイルで変数を表示する。

変数の定義インスタンスが翻訳単位で提供されていない場合、コンパイラは次があるものとみなす。
```lang:C
extern int x;
```

参照宣言と定義参照
```lang:C
int x = 0;
```

プログラムの別の翻訳単位に表示される。

3つの関数main,next,otherはすべて同じタスクを実行する。
iを増やし、それを出力する。(値4,5,6が出力される。)

変数iが初期化されていない場合、自動的に0に設定される。
値、1,2,3が出力される。
